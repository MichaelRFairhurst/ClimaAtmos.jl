using LinearAlgebra: √ó, norm, norm_sqr, dot

using ClimaCore: Operators, Fields

using Thermodynamics
using CLIMAParameters: AbstractEarthParameterSet, Planet, Atmos

const TD = Thermodynamics

include("schur_complement_W.jl")
include("hyperdiffusion.jl")

f_plane_coriolis_frequency(::AbstractEarthParameterSet) = 0

# Note: FT must be defined before `include("staggered_nonhydrostatic_model.jl")`

# Functions on which the model depends:
# Planet.R_d(params)         # dry specific gas constant
# Planet.kappa_d(params)     # dry adiabatic exponent
# Planet.T_triple(params)    # triple point temperature of water
# Planet.MSLP(params)        # reference pressure
# Planet.grav(params)        # gravitational acceleration
# Planet.Omega(params)       # rotation rate (only used if space is spherical)
# Planet.cv_d(params)        # dry isochoric specific heat capacity
# The value of cv_d is implied by the values of R_d and kappa_d

# The model also depends on f_plane_coriolis_frequency(params)
# This is a constant Coriolis frequency that is only used if space is flat

# To add additional terms to the explicit part of the tendency, define new
# methods for `additional_cache` and `additional_tendency!`.

const div‚Çï = Operators.Divergence()
const wdiv‚Çï = Operators.WeakDivergence()
const grad‚Çï = Operators.Gradient()
const wgrad‚Çï = Operators.WeakGradient()
const curl‚Çï = Operators.Curl()
const wcurl‚Çï = Operators.WeakCurl()

const ·∂úinterp = Operators.InterpolateF2C()
const ·∂†interp = Operators.InterpolateC2F(
    bottom = Operators.Extrapolate(),
    top = Operators.Extrapolate(),
)
const ·∂údiv·µ• = Operators.DivergenceF2C(
    top = Operators.SetValue(Geometry.Contravariant3Vector(FT(0))),
    bottom = Operators.SetValue(Geometry.Contravariant3Vector(FT(0))),
)
const ·∂†grad·µ• = Operators.GradientC2F(
    bottom = Operators.SetGradient(Geometry.Covariant3Vector(FT(0))),
    top = Operators.SetGradient(Geometry.Covariant3Vector(FT(0))),
)
const ·∂†curl·µ• = Operators.CurlC2F(
    bottom = Operators.SetCurl(Geometry.Contravariant12Vector(FT(0), FT(0))),
    top = Operators.SetCurl(Geometry.Contravariant12Vector(FT(0), FT(0))),
)
const ·∂úFC = Operators.FluxCorrectionC2C(
    bottom = Operators.Extrapolate(),
    top = Operators.Extrapolate(),
)
const ·∂†upwind_product1 = Operators.UpwindBiasedProductC2F()
const ·∂†upwind_product3 = Operators.Upwind3rdOrderBiasedProductC2F(
    bottom = Operators.FirstOrderOneSided(),
    top = Operators.FirstOrderOneSided(),
)

const ·∂úinterp_stencil = Operators.Operator2Stencil(·∂úinterp)
const ·∂†interp_stencil = Operators.Operator2Stencil(·∂†interp)
const ·∂údiv·µ•_stencil = Operators.Operator2Stencil(·∂údiv·µ•)
const ·∂†grad·µ•_stencil = Operators.Operator2Stencil(·∂†grad·µ•)

const C123 = Geometry.Covariant123Vector

include("thermo_states.jl")

get_cache(Y, params, upwinding_mode, dt) = merge(
    default_cache(Y, params, upwinding_mode),
    additional_cache(Y, params, dt),
)

function default_cache(Y, params, upwinding_mode)
    ·∂úcoord = Fields.local_geometry_field(Y.c).coordinates
    if eltype(·∂úcoord) <: Geometry.LatLongZPoint
        Œ© = FT(Planet.Omega(params))
        ·∂úf = @. 2 * Œ© * sind(·∂úcoord.lat)
    else
        f = FT(f_plane_coriolis_frequency(params))
        ·∂úf = map(_ -> f, ·∂úcoord)
    end
    ·∂úf = @. Geometry.Contravariant3Vector(Geometry.WVector(·∂úf))
    if (
        :œÅq_liq in propertynames(Y.c) &&
        :œÅq_ice in propertynames(Y.c) &&
        :œÅq_tot in propertynames(Y.c)
    )
        ts_type = TD.PhaseNonEquil{FT}
    elseif :œÅq_tot in propertynames(Y.c)
        ts_type = TD.PhaseEquil{FT}
    else
        ts_type = TD.PhaseDry{FT}
    end
    œÅe_int_kwarg = if :œÅe in propertynames(Y.c)
        (; œÅe_int = similar(Y.c.œÅ))
    else
        NamedTuple()
    end
    return (;
        ·∂úuvw = similar(Y.c, Geometry.Covariant123Vector{FT}),
        œÅe_int_kwarg...,
        ·∂úK = similar(Y.c, FT),
        ·∂úŒ¶ = FT(Planet.grav(params)) .* ·∂úcoord.z,
        ·∂úts = similar(Y.c, ts_type),
        ·∂úp = similar(Y.c, FT),
        ·∂úœâ¬≥ = similar(Y.c, Geometry.Contravariant3Vector{FT}),
        ·∂†œâ¬π¬≤ = similar(Y.f, Geometry.Contravariant12Vector{FT}),
        ·∂†u¬π¬≤ = similar(Y.f, Geometry.Contravariant12Vector{FT}),
        ·∂†u¬≥ = similar(Y.f, Geometry.Contravariant3Vector{FT}),
        ·∂úf,
        ‚àÇ·∂úK‚àÇ·∂†w_data = similar(
            Y.c,
            Operators.StencilCoefs{-half, half, NTuple{2, FT}},
        ),
        params,
        ·∂†upwind_product = upwinding_mode == :first_order ? ·∂†upwind_product1 :
                          upwinding_mode == :third_order ? ·∂†upwind_product3 :
                          nothing,
        ghost_buffer = (
            c = Spaces.create_ghost_buffer(Y.c),
            f = Spaces.create_ghost_buffer(Y.f),
            œá = Spaces.create_ghost_buffer(Y.c.œÅ), # for hyperdiffusion
            œáw = Spaces.create_ghost_buffer(Y.f.w.components.data.:1), # for hyperdiffusion
            œáu‚Çï = Spaces.create_ghost_buffer(Y.c.u‚Çï), # for hyperdiffusion
        ),
    )
end

function implicit_tendency!(Y‚Çú, Y, p, t)
    ·∂úœÅ = Y.c.œÅ
    dœÅ = Y‚Çú.c.œÅ
    ·∂úu‚Çï = Y.c.u‚Çï
    ·∂†w = Y.f.w
    (; ·∂úK, ·∂úŒ¶, ·∂úts, ·∂úp, params, ·∂†upwind_product) = p

    # Used for automatically computing the Jacobian ‚àÇY‚Çú/‚àÇY. Currently requires
    # allocation because the cache is stored separately from Y, which means that
    # similar(Y, <:Dual) doesn't allocate an appropriate cache for computing Y‚Çú.
    if eltype(Y) <: Dual
        ·∂úK = similar(·∂úœÅ)
        ·∂úts = similar(·∂úœÅ, eltype(·∂úts).name.wrapper{eltype(·∂úœÅ)})
        ·∂úp = similar(·∂úœÅ)
    end

    @. ·∂úK = norm_sqr(C123(·∂úu‚Çï) + C123(·∂úinterp(·∂†w))) / 2

    @. dœÅ = -(·∂údiv·µ•(·∂†interp(·∂úœÅ) * ·∂†w))

    if :œÅŒ∏ in propertynames(Y.c)
        œÅŒ∏ = Y.c.œÅŒ∏
        dœÅŒ∏ = Y‚Çú.c.œÅŒ∏
        set_thermo_state!(·∂úts, Y.c, params)
        # @. ·∂úts = thermo_state_œÅŒ∏(œÅŒ∏, Y.c, params)
        @. ·∂úp = TD.air_pressure(params, ·∂úts)
        if isnothing(·∂†upwind_product)
            @. dœÅŒ∏ = -(·∂údiv·µ•(·∂†interp(œÅŒ∏) * ·∂†w))
        else
            @. dœÅŒ∏ = -(·∂údiv·µ•(·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w, œÅŒ∏ / ·∂úœÅ)))
        end
    elseif :œÅe in propertynames(Y.c)
        œÅe = Y.c.œÅe
        dœÅe = Y‚Çú.c.œÅe
        set_thermo_state!(·∂úts, Y.c, params, ·∂úK, ·∂úŒ¶, p.œÅe_int)
        # @. ·∂úts = thermo_state_œÅe(œÅe, Y.c, ·∂úK, ·∂úŒ¶, params)
        @. ·∂úp = TD.air_pressure(params, ·∂úts)
        if isnothing(·∂†upwind_product)
            @. dœÅe = -(·∂údiv·µ•(·∂†interp(œÅe + ·∂úp) * ·∂†w))
        else
            @. dœÅe = -(·∂údiv·µ•(·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w, (œÅe + ·∂úp) / ·∂úœÅ)))
        end
    elseif :œÅe_int in propertynames(Y.c)
        œÅe_int = Y.c.œÅe_int
        dœÅe_int = Y‚Çú.c.œÅe_int
        set_thermo_state!(·∂úts, Y.c, params)
        # @. ·∂úts = thermo_state_œÅe_int(œÅe_int, Y.c, params)
        @. ·∂úp = TD.air_pressure(params, ·∂úts)
        if isnothing(·∂†upwind_product)
            @. dœÅe_int =
                -(
                    ·∂údiv·µ•(·∂†interp(œÅe_int + ·∂úp) * ·∂†w) -
                    ·∂úinterp(dot(·∂†grad·µ•(·∂úp), Geometry.Contravariant3Vector(·∂†w)))
                )
            # or, equivalently,
            # Y‚Çú.c.œÅe_int = -(·∂údiv·µ•(·∂†interp(Y.c.œÅe_int) * ·∂†w) + ·∂úp * ·∂údiv·µ•(·∂†w))
        else
            @. dœÅe_int =
                -(
                    ·∂údiv·µ•(
                        ·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w, (œÅe_int + ·∂úp) / ·∂úœÅ),
                    ) -
                    ·∂úinterp(dot(·∂†grad·µ•(·∂úp), Geometry.Contravariant3Vector(·∂†w)))
                )
        end
    end

    # TODO: Add flux correction to the Jacobian
    # @. Y‚Çú.c.œÅ += ·∂úFC(·∂†w, ·∂úœÅ)
    # if :œÅŒ∏ in propertynames(Y.c)
    #     @. Y‚Çú.c.œÅŒ∏ += ·∂úFC(·∂†w, ·∂úœÅŒ∏)
    # elseif :œÅe in propertynames(Y.c)
    #     @. Y‚Çú.c.œÅe += ·∂úFC(·∂†w, ·∂úœÅe)
    # elseif :œÅe_int in propertynames(Y.c)
    #     @. Y‚Çú.c.œÅe_int += ·∂úFC(·∂†w, ·∂úœÅe_int)
    # end

    Y‚Çú.c.u‚Çï .= Ref(zero(eltype(Y‚Çú.c.u‚Çï)))

    @. Y‚Çú.f.w = -(·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) + ·∂†grad·µ•(·∂úK + ·∂úŒ¶))

    for ·∂úùïã_name in filter(is_tracer_var, propertynames(Y.c))
        ·∂úùïã = getproperty(Y.c, ·∂úùïã_name)
        ·∂úùïã‚Çú = getproperty(Y‚Çú.c, ·∂úùïã_name)
        if isnothing(·∂†upwind_product)
            @. ·∂úùïã‚Çú = -(·∂údiv·µ•(·∂†interp(·∂úùïã) * ·∂†w))
        else
            @. ·∂úùïã‚Çú = -(·∂údiv·µ•(·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w, ·∂úùïã / ·∂úœÅ)))
        end
    end

    return Y‚Çú
end

function remaining_tendency!(Y‚Çú, Y, p, t)
    Y‚Çú .= zero(eltype(Y‚Çú))
    default_remaining_tendency!(Y‚Çú, Y, p, t)
    additional_tendency!(Y‚Çú, Y, p, t)
    Spaces.weighted_dss!(Y‚Çú.c, p.ghost_buffer.c)
    Spaces.weighted_dss!(Y‚Çú.f, p.ghost_buffer.f)
    return Y‚Çú
end

function default_remaining_tendency!(Y‚Çú, Y, p, t)
    ·∂úœÅ = Y.c.œÅ
    ·∂úu‚Çï = Y.c.u‚Çï
    ·∂†w = Y.f.w
    (; ·∂úuvw, ·∂úK, ·∂úŒ¶, ·∂úts, ·∂úp, ·∂úœâ¬≥, ·∂†œâ¬π¬≤, ·∂†u¬π¬≤, ·∂†u¬≥, ·∂úf, params) = p
    point_type = eltype(Fields.local_geometry_field(axes(Y.c)).coordinates)

    @. ·∂úuvw = C123(·∂úu‚Çï) + C123(·∂úinterp(·∂†w))
    @. ·∂úK = norm_sqr(·∂úuvw) / 2

    # Mass conservation

    @. Y‚Çú.c.œÅ -= div‚Çï(·∂úœÅ * ·∂úuvw)
    @. Y‚Çú.c.œÅ -= ·∂údiv·µ•(·∂†interp(·∂úœÅ * ·∂úu‚Çï))

    # Energy conservation

    if :œÅŒ∏ in propertynames(Y.c)
        set_thermo_state!(·∂úts, Y.c, params)
        # @. ·∂úts = thermo_state_œÅŒ∏(Y.c.œÅŒ∏, Y.c, params)
        @. ·∂úp = TD.air_pressure(params, ·∂úts)
        @. Y‚Çú.c.œÅŒ∏ -= div‚Çï(Y.c.œÅŒ∏ * ·∂úuvw)
        @. Y‚Çú.c.œÅŒ∏ -= ·∂údiv·µ•(·∂†interp(Y.c.œÅŒ∏ * ·∂úu‚Çï))
    elseif :œÅe in propertynames(Y.c)
        set_thermo_state!(·∂úts, Y.c, params, ·∂úK, ·∂úŒ¶, p.œÅe_int)
        # @. ·∂úts = thermo_state_œÅe(Y.c.œÅe, Y.c, ·∂úK, ·∂úŒ¶, params)
        @. ·∂úp = TD.air_pressure(params, ·∂úts)
        @. Y‚Çú.c.œÅe -= div‚Çï((Y.c.œÅe + ·∂úp) * ·∂úuvw)
        @. Y‚Çú.c.œÅe -= ·∂údiv·µ•(·∂†interp((Y.c.œÅe + ·∂úp) * ·∂úu‚Çï))
    elseif :œÅe_int in propertynames(Y.c)
        set_thermo_state!(·∂úts, Y.c, params)
        # @. ·∂úts = thermo_state_œÅe_int(Y.c.œÅe_int, Y.c, params)
        @. ·∂úp = TD.air_pressure(params, ·∂úts)
        if point_type <: Geometry.Abstract3DPoint
            @. Y‚Çú.c.œÅe_int -=
                div‚Çï((Y.c.œÅe_int + ·∂úp) * ·∂úuvw) -
                dot(grad‚Çï(·∂úp), Geometry.Contravariant12Vector(·∂úu‚Çï))
        else
            @. Y‚Çú.c.œÅe_int -=
                div‚Çï((Y.c.œÅe_int + ·∂úp) * ·∂úuvw) -
                dot(grad‚Çï(·∂úp), Geometry.Contravariant1Vector(·∂úu‚Çï))
        end
        @. Y‚Çú.c.œÅe_int -= ·∂údiv·µ•(·∂†interp((Y.c.œÅe_int + ·∂úp) * ·∂úu‚Çï))
        # or, equivalently,
        # @. Y‚Çú.c.œÅe_int -= div‚Çï(Y.c.œÅe_int * ·∂úuvw) + ·∂úp * div‚Çï(·∂úuvw)
        # @. Y‚Çú.c.œÅe_int -=
        #     ·∂údiv·µ•(·∂†interp(Y.c.œÅe_int * ·∂úu‚Çï)) + ·∂úp * ·∂údiv·µ•(·∂†interp(·∂úu‚Çï))
    end

    # Momentum conservation

    if point_type <: Geometry.Abstract3DPoint
        @. ·∂úœâ¬≥ = curl‚Çï(·∂úu‚Çï)
        @. ·∂†œâ¬π¬≤ = curl‚Çï(·∂†w)
    elseif point_type <: Geometry.Abstract2DPoint
        ·∂úœâ¬≥ .= Ref(zero(eltype(·∂úœâ¬≥)))
        @. ·∂†œâ¬π¬≤ = Geometry.Contravariant12Vector(curl‚Çï(·∂†w))
    end
    @. ·∂†œâ¬π¬≤ += ·∂†curl·µ•(·∂úu‚Çï)

    # TODO: Modify to account for topography
    @. ·∂†u¬π¬≤ = Geometry.Contravariant12Vector(·∂†interp(·∂úu‚Çï))
    @. ·∂†u¬≥ = Geometry.Contravariant3Vector(·∂†w)

    @. Y‚Çú.c.u‚Çï -=
        ·∂úinterp(·∂†œâ¬π¬≤ √ó ·∂†u¬≥) + (·∂úf + ·∂úœâ¬≥) √ó Geometry.Contravariant12Vector(·∂úu‚Çï)
    if point_type <: Geometry.Abstract3DPoint
        @. Y‚Çú.c.u‚Çï -= grad‚Çï(·∂úp) / ·∂úœÅ + grad‚Çï(·∂úK + ·∂úŒ¶)
    elseif point_type <: Geometry.Abstract2DPoint
        @. Y‚Çú.c.u‚Çï -=
            Geometry.Covariant12Vector(grad‚Çï(·∂úp) / ·∂úœÅ + grad‚Çï(·∂úK + ·∂úŒ¶))
    end

    @. Y‚Çú.f.w -= ·∂†œâ¬π¬≤ √ó ·∂†u¬π¬≤

    # Tracer conservation

    for ·∂úùïã_name in filter(is_tracer_var, propertynames(Y.c))
        ·∂úùïã = getproperty(Y.c, ·∂úùïã_name)
        ·∂úùïã‚Çú = getproperty(Y‚Çú.c, ·∂úùïã_name)
        @. ·∂úùïã‚Çú -= div‚Çï(·∂úùïã * ·∂úuvw)
        @. ·∂úùïã‚Çú -= ·∂údiv·µ•(·∂†interp(·∂úùïã * ·∂úu‚Çï))
    end
end

# Allow one() to be called on vectors.
Base.one(::T) where {T <: Geometry.AxisTensor} = one(T)
Base.one(::Type{T}) where {T‚Ä≤, A, S, T <: Geometry.AxisTensor{T‚Ä≤, 1, A, S}} =
    T(axes(T), S(one(T‚Ä≤)))

function Wfact!(W, Y, p, dtŒ≥, t)
    (; flags, dtŒ≥_ref) = W
    (; ‚àÇ·∂úœÅ‚Çú‚àÇ·∂†ùïÑ, ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ, ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úùîº, ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ, ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂†ùïÑ, ‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ_named_tuple) = W
    ·∂úœÅ = Y.c.œÅ
    ·∂úu‚Çï = Y.c.u‚Çï
    ·∂†w = Y.f.w
    (; ·∂úK, ·∂úŒ¶, ·∂úts, ·∂úp, ‚àÇ·∂úK‚àÇ·∂†w_data, params, ·∂†upwind_product) = p

    R_d = FT(Planet.R_d(params))
    Œ∫_d = FT(Planet.kappa_d(params))
    cv_d = FT(Planet.cv_d(params))
    T_tri = FT(Planet.T_triple(params))
    MSLP = FT(Planet.MSLP(params))

    dtŒ≥_ref[] = dtŒ≥

    # If we let ·∂†w_data = ·∂†w.components.data.:1 and ·∂†w_unit = one.(·∂†w), then
    # ·∂†w == ·∂†w_data .* ·∂†w_unit. The Jacobian blocks involve ·∂†w_data, not ·∂†w.
    ·∂†w_data = ·∂†w.components.data.:1

    # If ‚àÇ(·∂úarg)/‚àÇ(·∂†w_data) = 0, then
    # ‚àÇ(·∂†upwind_product(·∂†w, ·∂úarg))/‚àÇ(·∂†w_data) =
    #     ·∂†upwind_product(·∂†w + Œµw, arg) / to_scalar(·∂†w + Œµw).
    # The Œµw is only necessary in case w = 0.
    Œµw = Ref(Geometry.Covariant3Vector(eps(FT)))
    to_scalar(vector) = vector.u‚ÇÉ

    # ·∂úinterp(·∂†w) =
    #     ·∂úinterp(·∂†w)_data * ·∂úinterp(·∂†w)_unit =
    #     ·∂úinterp(·∂†w_data) * ·∂úinterp(·∂†w)_unit
    # norm_sqr(·∂úinterp(·∂†w)) =
    #     norm_sqr(·∂úinterp(·∂†w_data) * ·∂úinterp(·∂†w)_unit) =
    #     ·∂úinterp(·∂†w_data)^2 * norm_sqr(·∂úinterp(·∂†w)_unit)
    # ·∂úK =
    #     norm_sqr(C123(·∂úu‚Çï) + C123(·∂úinterp(·∂†w))) / 2 =
    #     norm_sqr(·∂úu‚Çï) / 2 + norm_sqr(·∂úinterp(·∂†w)) / 2 =
    #     norm_sqr(·∂úu‚Çï) / 2 + ·∂úinterp(·∂†w_data)^2 * norm_sqr(·∂úinterp(·∂†w)_unit) / 2
    # ‚àÇ(·∂úK)/‚àÇ(·∂†w_data) =
    #     ‚àÇ(·∂úK)/‚àÇ(·∂úinterp(·∂†w_data)) * ‚àÇ(·∂úinterp(·∂†w_data))/‚àÇ(·∂†w_data) =
    #     ·∂úinterp(·∂†w_data) * norm_sqr(·∂úinterp(·∂†w)_unit) * ·∂úinterp_stencil(1)
    @. ‚àÇ·∂úK‚àÇ·∂†w_data =
        ·∂úinterp(·∂†w_data) *
        norm_sqr(one(·∂úinterp(·∂†w))) *
        ·∂úinterp_stencil(one(·∂†w_data))

    # ·∂úœÅ‚Çú = -·∂údiv·µ•(·∂†interp(·∂úœÅ) * ·∂†w)
    # ‚àÇ(·∂úœÅ‚Çú)/‚àÇ(·∂†w_data) = -·∂údiv·µ•_stencil(·∂†interp(·∂úœÅ) * ·∂†w_unit)
    @. ‚àÇ·∂úœÅ‚Çú‚àÇ·∂†ùïÑ = -(·∂údiv·µ•_stencil(·∂†interp(·∂úœÅ) * one(·∂†w)))

    if :œÅŒ∏ in propertynames(Y.c)
        ·∂úœÅŒ∏ = Y.c.œÅŒ∏
        set_thermo_state!(·∂úts, Y.c, params)
        # @. ·∂úts = thermo_state_œÅŒ∏(Y.c.œÅŒ∏, Y.c, params)
        @. ·∂úp = TD.air_pressure(params, ·∂úts)

        if flags.‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode != :exact
            error("‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode must be :exact when using œÅŒ∏")
        end

        if isnothing(·∂†upwind_product)
            # ·∂úœÅŒ∏‚Çú = -·∂údiv·µ•(·∂†interp(·∂úœÅŒ∏) * ·∂†w)
            # ‚àÇ(·∂úœÅŒ∏‚Çú)/‚àÇ(·∂†w_data) = -·∂údiv·µ•_stencil(·∂†interp(·∂úœÅŒ∏) * ·∂†w_unit)
            @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ = -(·∂údiv·µ•_stencil(·∂†interp(·∂úœÅŒ∏) * one(·∂†w)))
        else
            # ·∂úœÅŒ∏‚Çú = -·∂údiv·µ•(·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w, ·∂úœÅŒ∏ / ·∂úœÅ))
            # ‚àÇ(·∂úœÅŒ∏‚Çú)/‚àÇ(·∂†w_data) =
            #     -·∂údiv·µ•_stencil(
            #         ·∂†interp(·∂úœÅ) * ‚àÇ(·∂†upwind_product(·∂†w, ·∂úœÅŒ∏ / ·∂úœÅ))/‚àÇ(·∂†w_data),
            #     )
            @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ =
                -(·∂údiv·µ•_stencil(
                    ·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w + Œµw, ·∂úœÅŒ∏ / ·∂úœÅ) /
                    to_scalar(·∂†w + Œµw),
                ))
        end
    elseif :œÅe in propertynames(Y.c)
        ·∂úœÅe = Y.c.œÅe
        @. ·∂úK = norm_sqr(C123(·∂úu‚Çï) + C123(·∂úinterp(·∂†w))) / 2
        set_thermo_state!(·∂úts, Y.c, params, ·∂úK, ·∂úŒ¶, p.œÅe_int)
        # @. ·∂úts = thermo_state_œÅe(Y.c.œÅe, Y.c, ·∂úK, ·∂úŒ¶, params)
        @. ·∂úp = TD.air_pressure(params, ·∂úts)

        if isnothing(·∂†upwind_product)
            if flags.‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode == :exact
                # ·∂úœÅe‚Çú = -·∂údiv·µ•(·∂†interp(·∂úœÅe + ·∂úp) * ·∂†w)
                # ‚àÇ(·∂úœÅe‚Çú)/‚àÇ(·∂†w_data) =
                #     -·∂údiv·µ•_stencil(·∂†interp(·∂úœÅe + ·∂úp) * ·∂†w_unit) -
                #     ·∂údiv·µ•_stencil(·∂†w) * ‚àÇ(·∂†interp(·∂úœÅe + ·∂úp))/‚àÇ(·∂†w_data)
                # ‚àÇ(·∂†interp(·∂úœÅe + ·∂úp))/‚àÇ(·∂†w_data) =
                #     ‚àÇ(·∂†interp(·∂úœÅe + ·∂úp))/‚àÇ(·∂úp) * ‚àÇ(·∂úp)/‚àÇ(·∂†w_data)
                # ‚àÇ(·∂†interp(·∂úœÅe + ·∂úp))/‚àÇ(·∂úp) = ·∂†interp_stencil(1)
                # ‚àÇ(·∂úp)/‚àÇ(·∂†w_data) = ‚àÇ(·∂úp)/‚àÇ(·∂úK) * ‚àÇ(·∂úK)/‚àÇ(·∂†w_data)
                # ‚àÇ(·∂úp)/‚àÇ(·∂úK) = -·∂úœÅ * R_d / cv_d
                @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ =
                    -(·∂údiv·µ•_stencil(·∂†interp(·∂úœÅe + ·∂úp) * one(·∂†w))) - compose(
                        ·∂údiv·µ•_stencil(·∂†w),
                        compose(
                            ·∂†interp_stencil(one(·∂úp)),
                            -(·∂úœÅ * R_d / cv_d) * ‚àÇ·∂úK‚àÇ·∂†w_data,
                        ),
                    )
            elseif flags.‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode == :no_‚àÇ·∂úp‚àÇ·∂úK
                # same as above, but we approximate ‚àÇ(·∂úp)/‚àÇ(·∂úK) = 0, so that
                # ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ has 3 diagonals instead of 5
                @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ = -(·∂údiv·µ•_stencil(·∂†interp(·∂úœÅe + ·∂úp) * one(·∂†w)))
            else
                error("‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode must be :exact or :no_‚àÇ·∂úp‚àÇ·∂úK when using œÅe \
                       without upwinding")
            end
        else
            # TODO: Add Operator2Stencil for UpwindBiasedProductC2F to ClimaCore
            # to allow exact Jacobian calculation.
            if flags.‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode == :no_‚àÇ·∂úp‚àÇ·∂úK
                # ·∂úœÅe‚Çú =
                #     -·∂údiv·µ•(·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w, (·∂úœÅe + ·∂úp) / ·∂úœÅ))
                # ‚àÇ(·∂úœÅe‚Çú)/‚àÇ(·∂†w_data) =
                #     -·∂údiv·µ•_stencil(
                #         ·∂†interp(·∂úœÅ) *
                #         ‚àÇ(·∂†upwind_product(·∂†w, (·∂úœÅe + ·∂úp) / ·∂úœÅ))/‚àÇ(·∂†w_data),
                #     )
                @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ =
                    -(·∂údiv·µ•_stencil(
                        ·∂†interp(·∂úœÅ) *
                        ·∂†upwind_product(·∂†w + Œµw, (·∂úœÅe + ·∂úp) / ·∂úœÅ) /
                        to_scalar(·∂†w + Œµw),
                    ))
            else
                error("‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode must be :no_‚àÇ·∂úp‚àÇ·∂úK when using œÅe with \
                       upwinding")
            end
        end
    elseif :œÅe_int in propertynames(Y.c)
        ·∂úœÅe_int = Y.c.œÅe_int
        set_thermo_state!(·∂úts, Y.c, params)
        # @. ·∂úts = thermo_state_œÅe_int(Y.c.œÅe_int, Y.c, params)
        @. ·∂úp = TD.air_pressure(params, ·∂úts)

        if flags.‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode != :exact
            error("‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode must be :exact when using œÅe_int")
        end

        if isnothing(·∂†upwind_product)
            # ·∂úœÅe_int‚Çú =
            #     -(
            #         ·∂údiv·µ•(·∂†interp(·∂úœÅe_int + ·∂úp) * ·∂†w) -
            #         ·∂úinterp(dot(·∂†grad·µ•(·∂úp), Geometry.Contravariant3Vector(·∂†w))
            #     )
            # ‚àÇ(·∂úœÅe_int‚Çú)/‚àÇ(·∂†w_data) =
            #     -(
            #         ·∂údiv·µ•_stencil(·∂†interp(·∂úœÅe_int + ·∂úp) * ·∂†w_unit) -
            #         ·∂úinterp_stencil(dot(
            #             ·∂†grad·µ•(·∂úp),
            #             Geometry.Contravariant3Vector(·∂†w_unit),
            #         ),)
            #     )
            @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ =
                -(
                    ·∂údiv·µ•_stencil(·∂†interp(·∂úœÅe_int + ·∂úp) * one(·∂†w)) -
                    ·∂úinterp_stencil(dot(
                        ·∂†grad·µ•(·∂úp),
                        Geometry.Contravariant3Vector(one(·∂†w)),
                    ),)
                )
        else
            # ·∂úœÅe_int‚Çú =
            #     -(
            #         ·∂údiv·µ•(
            #             ·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w, (·∂úœÅe_int + ·∂úp) / ·∂úœÅ),
            #         ) -
            #         ·∂úinterp(dot(·∂†grad·µ•(·∂úp), Geometry.Contravariant3Vector(·∂†w)))
            #     )
            # ‚àÇ(·∂úœÅe_int‚Çú)/‚àÇ(·∂†w_data) =
            #     -(
            #         ·∂údiv·µ•_stencil(
            #             ·∂†interp(·∂úœÅ) *
            #             ‚àÇ(·∂†upwind_product(·∂†w, (·∂úœÅe_int + ·∂úp) / ·∂úœÅ))/‚àÇ(·∂†w_data),
            #         ) -
            #         ·∂úinterp_stencil(dot(
            #             ·∂†grad·µ•(·∂úp),
            #             Geometry.Contravariant3Vector(·∂†w_unit),
            #         ),)
            #     )
            @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ =
                -(
                    ·∂údiv·µ•_stencil(
                        ·∂†interp(·∂úœÅ) *
                        ·∂†upwind_product(·∂†w + Œµw, (·∂úœÅe_int + ·∂úp) / ·∂úœÅ) /
                        to_scalar(·∂†w + Œµw),
                    ) - ·∂úinterp_stencil(dot(
                        ·∂†grad·µ•(·∂úp),
                        Geometry.Contravariant3Vector(one(·∂†w)),
                    ),)
                )
        end
    end

    # To convert ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úùîº) to ‚àÇ(·∂†w_data)‚Çú/‚àÇ(·∂úùîº) and ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†w_data) to
    # ‚àÇ(·∂†w_data)‚Çú/‚àÇ(·∂†w_data), we must extract the third component of each
    # vector-valued stencil coefficient.
    to_scalar_coefs(vector_coefs) =
        map(vector_coef -> vector_coef.u‚ÇÉ, vector_coefs)

    # TODO: If we end up using :gradŒ¶_shenanigans, optimize it to
    # `cached_stencil / ·∂†interp(·∂úœÅ)`.
    if flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode != :exact && flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode != :gradŒ¶_shenanigans
        error("‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode must be :exact or :gradŒ¶_shenanigans")
    end
    if :œÅŒ∏ in propertynames(Y.c)
        # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
        # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úœÅŒ∏) = ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅŒ∏)
        # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) = -1 / ·∂†interp(·∂úœÅ)
        # ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅŒ∏) =
        #     ·∂†grad·µ•_stencil(
        #         R_d / (1 - Œ∫_d) * (·∂úœÅŒ∏ * R_d / MSLP)^(Œ∫_d / (1 - Œ∫_d))
        #     )
        @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úùîº = to_scalar_coefs(
            -1 / ·∂†interp(·∂úœÅ) * ·∂†grad·µ•_stencil(
                R_d / (1 - Œ∫_d) * (·∂úœÅŒ∏ * R_d / MSLP)^(Œ∫_d / (1 - Œ∫_d)),
            ),
        )

        if flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :exact
            # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úœÅ) = ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†interp(·∂úœÅ)) * ‚àÇ(·∂†interp(·∂úœÅ))/‚àÇ(·∂úœÅ)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†interp(·∂úœÅ)) = ·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ)^2
            # ‚àÇ(·∂†interp(·∂úœÅ))/‚àÇ(·∂úœÅ) = ·∂†interp_stencil(1)
            @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ = to_scalar_coefs(
                ·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ)^2 * ·∂†interp_stencil(one(·∂úœÅ)),
            )
        elseif flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :gradŒ¶_shenanigans
            # ·∂†w‚Çú = (
            #     -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ‚Ä≤) -
            #     ·∂†grad·µ•(·∂úŒ¶) / ·∂†interp(·∂úœÅ‚Ä≤) * ·∂†interp(·∂úœÅ)
            # ), where ·∂úœÅ‚Ä≤ = ·∂úœÅ but we approximate ‚àÇ(·∂úœÅ‚Ä≤)/‚àÇ(·∂úœÅ) = 0
            @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ = to_scalar_coefs(
                -(·∂†grad·µ•(·∂úŒ¶)) / ·∂†interp(·∂úœÅ) * ·∂†interp_stencil(one(·∂úœÅ)),
            )
        end
    elseif :œÅe in propertynames(Y.c)
        # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
        # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úœÅe) = ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅe)
        # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) = -1 / ·∂†interp(·∂úœÅ)
        # ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅe) = ·∂†grad·µ•_stencil(R_d / cv_d)
        @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úùîº = to_scalar_coefs(
            -1 / ·∂†interp(·∂úœÅ) * ·∂†grad·µ•_stencil(R_d / cv_d * one(·∂úœÅe)),
        )

        if flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :exact
            # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úœÅ) =
            #     ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅ) +
            #     ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†interp(·∂úœÅ)) * ‚àÇ(·∂†interp(·∂úœÅ))/‚àÇ(·∂úœÅ)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) = -1 / ·∂†interp(·∂úœÅ)
            # ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅ) =
            #     ·∂†grad·µ•_stencil(R_d * (-(·∂úK + ·∂úŒ¶) / cv_d + T_tri))
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†interp(·∂úœÅ)) = ·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ)^2
            # ‚àÇ(·∂†interp(·∂úœÅ))/‚àÇ(·∂úœÅ) = ·∂†interp_stencil(1)
            @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ = to_scalar_coefs(
                -1 / ·∂†interp(·∂úœÅ) *
                ·∂†grad·µ•_stencil(R_d * (-(·∂úK + ·∂úŒ¶) / cv_d + T_tri)) +
                ·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ)^2 * ·∂†interp_stencil(one(·∂úœÅ)),
            )
        elseif flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :gradŒ¶_shenanigans
            # ·∂†w‚Çú = (
            #     -·∂†grad·µ•(·∂úp‚Ä≤) / ·∂†interp(·∂úœÅ‚Ä≤) -
            #     ·∂†grad·µ•(·∂úŒ¶) / ·∂†interp(·∂úœÅ‚Ä≤) * ·∂†interp(·∂úœÅ)
            # ), where ·∂úœÅ‚Ä≤ = ·∂úœÅ but we approximate ‚àÇ·∂úœÅ‚Ä≤/‚àÇ·∂úœÅ = 0, and where
            # ·∂úp‚Ä≤ = ·∂úp but with ·∂úK = 0
            @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ = to_scalar_coefs(
                -1 / ·∂†interp(·∂úœÅ) *
                ·∂†grad·µ•_stencil(R_d * (-(·∂úŒ¶) / cv_d + T_tri)) -
                ·∂†grad·µ•(·∂úŒ¶) / ·∂†interp(·∂úœÅ) * ·∂†interp_stencil(one(·∂úœÅ)),
            )
        end
    elseif :œÅe_int in propertynames(Y.c)
        # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
        # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úœÅe_int) = ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅe_int)
        # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) = -1 / ·∂†interp(·∂úœÅ)
        # ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅe_int) = ·∂†grad·µ•_stencil(R_d / cv_d)
        @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úùîº = to_scalar_coefs(
            -1 / ·∂†interp(·∂úœÅ) * ·∂†grad·µ•_stencil(R_d / cv_d * one(·∂úœÅe_int)),
        )

        if flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :exact
            # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂úœÅ) =
            #     ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅ) +
            #     ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†interp(·∂úœÅ)) * ‚àÇ(·∂†interp(·∂úœÅ))/‚àÇ(·∂úœÅ)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) = -1 / ·∂†interp(·∂úœÅ)
            # ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úœÅ) = ·∂†grad·µ•_stencil(R_d * T_tri)
            # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†interp(·∂úœÅ)) = ·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ)^2
            # ‚àÇ(·∂†interp(·∂úœÅ))/‚àÇ(·∂úœÅ) = ·∂†interp_stencil(1)
            @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ = to_scalar_coefs(
                -1 / ·∂†interp(·∂úœÅ) * ·∂†grad·µ•_stencil(R_d * T_tri * one(·∂úœÅe_int)) +
                ·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ)^2 * ·∂†interp_stencil(one(·∂úœÅ)),
            )
        elseif flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :gradŒ¶_shenanigans
            # ·∂†w‚Çú = (
            #     -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ‚Ä≤) -
            #     ·∂†grad·µ•(·∂úŒ¶) / ·∂†interp(·∂úœÅ‚Ä≤) * ·∂†interp(·∂úœÅ)
            # ), where ·∂úp‚Ä≤ = ·∂úp but we approximate ‚àÇ·∂úœÅ‚Ä≤/‚àÇ·∂úœÅ = 0
            @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ = to_scalar_coefs(
                -1 / ·∂†interp(·∂úœÅ) * ·∂†grad·µ•_stencil(R_d * T_tri * one(·∂úœÅe_int)) -
                ·∂†grad·µ•(·∂úŒ¶) / ·∂†interp(·∂úœÅ) * ·∂†interp_stencil(one(·∂úœÅ)),
            )
        end
    end

    # ·∂†w‚Çú = -·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) - ·∂†grad·µ•(·∂úK + ·∂úŒ¶)
    # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†w_data) =
    #     ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂†w_data‚Çú) +
    #     ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úK + ·∂úŒ¶)) * ‚àÇ(·∂†grad·µ•(·∂úK + ·∂úŒ¶))/‚àÇ(·∂†w_data‚Çú) =
    #     (
    #         ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) * ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úK) +
    #         ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úK + ·∂úŒ¶)) * ‚àÇ(·∂†grad·µ•(·∂úK + ·∂úŒ¶))/‚àÇ(·∂úK)
    #     ) * ‚àÇ(·∂úK)/‚àÇ(·∂†w_data‚Çú)
    # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úp)) = -1 / ·∂†interp(·∂úœÅ)
    # ‚àÇ(·∂†grad·µ•(·∂úp))/‚àÇ(·∂úK) =
    #     ·∂úùîº_name == :œÅe ? ·∂†grad·µ•_stencil(-·∂úœÅ * R_d / cv_d) : 0
    # ‚àÇ(·∂†w‚Çú)/‚àÇ(·∂†grad·µ•(·∂úK + ·∂úŒ¶)) = -1
    # ‚àÇ(·∂†grad·µ•(·∂úK + ·∂úŒ¶))/‚àÇ(·∂úK) = ·∂†grad·µ•_stencil(1)
    # ‚àÇ(·∂úK)/‚àÇ(·∂†w_data) =
    #     ·∂úinterp(·∂†w_data) * norm_sqr(·∂úinterp(·∂†w)_unit) * ·∂úinterp_stencil(1)
    if :œÅŒ∏ in propertynames(Y.c) || :œÅe_int in propertynames(Y.c)
        @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂†ùïÑ =
            to_scalar_coefs(compose(-1 * ·∂†grad·µ•_stencil(one(·∂úK)), ‚àÇ·∂úK‚àÇ·∂†w_data))
    elseif :œÅe in propertynames(Y.c)
        @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂†ùïÑ = to_scalar_coefs(compose(
            -1 / ·∂†interp(·∂úœÅ) * ·∂†grad·µ•_stencil(-(·∂úœÅ * R_d / cv_d)) +
            -1 * ·∂†grad·µ•_stencil(one(·∂úK)),
            ‚àÇ·∂úK‚àÇ·∂†w_data,
        ),)
    end

    for ·∂úùïã_name in filter(is_tracer_var, propertynames(Y.c))
        ·∂úùïã = getproperty(Y.c, ·∂úùïã_name)
        ‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ = getproperty(‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ_named_tuple, ·∂úùïã_name)
        if isnothing(·∂†upwind_product)
            # ·∂úùïã‚Çú = -·∂údiv·µ•(·∂†interp(·∂úùïã) * ·∂†w)
            # ‚àÇ(·∂úùïã‚Çú)/‚àÇ(·∂†w_data) = -·∂údiv·µ•_stencil(·∂†interp(·∂úùïã) * ·∂†w_unit)
            @. ‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ = -(·∂údiv·µ•_stencil(·∂†interp(·∂úùïã) * one(·∂†w)))
        else
            # ·∂úùïã‚Çú = -·∂údiv·µ•(·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w, ·∂úùïã / ·∂úœÅ))
            # ‚àÇ(·∂úùïã‚Çú)/‚àÇ(·∂†w_data) =
            #     -·∂údiv·µ•_stencil(
            #         ·∂†interp(·∂úœÅ) * ‚àÇ(·∂†upwind_product(·∂†w, ·∂úùïã / ·∂úœÅ))/‚àÇ(·∂†w_data),
            #     )
            @. ‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ =
                -(·∂údiv·µ•_stencil(
                    ·∂†interp(·∂úœÅ) * ·∂†upwind_product(·∂†w + Œµw, ·∂úùïã / ·∂úœÅ) /
                    to_scalar(·∂†w + Œµw),
                ))
        end
    end

    # TODO: Figure out a way to test the Jacobian when the thermodynamic state
    # is PhaseEquil (i.e., when implicit_tendency! calls saturation adjustment).
    if W.test && !(eltype(·∂úts) <: TD.PhaseEquil)
        # Checking every column takes too long, so just check one.
        i, j, h = 1, 1, 1
        args = (implicit_tendency!, Y, p, t, i, j, h)
        ·∂úùîº_name = filter(is_energy_var, propertynames(Y.c))[1]

        @assert matrix_column(‚àÇ·∂úœÅ‚Çú‚àÇ·∂†ùïÑ, axes(Y.f), i, j, h) ==
                exact_column_jacobian_block(args..., (:c, :œÅ), (:f, :w))
        @assert matrix_column(‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úùîº, axes(Y.c), i, j, h) ‚âà
                exact_column_jacobian_block(args..., (:f, :w), (:c, ·∂úùîº_name))
        @assert matrix_column(‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂†ùïÑ, axes(Y.f), i, j, h) ‚âà
                exact_column_jacobian_block(args..., (:f, :w), (:f, :w))
        for ·∂úùïã_name in filter(is_tracer_var, propertynames(Y.c))
            ‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ = getproperty(‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ_named_tuple, ·∂úùïã_name)
            ·∂úùïã_tuple = (:c, ·∂úùïã_name)
            @assert matrix_column(‚àÇ·∂úùïã‚Çú‚àÇ·∂†ùïÑ, axes(Y.f), i, j, h) ‚âà
                    exact_column_jacobian_block(args..., ·∂úùïã_tuple, (:f, :w))
        end

        ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_approx = matrix_column(‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ, axes(Y.f), i, j, h)
        ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_exact =
            exact_column_jacobian_block(args..., (:c, ·∂úùîº_name), (:f, :w))
        if flags.‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode == :exact
            @assert ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_approx ‚âà ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_exact
        else
            err = norm(‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_approx .- ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_exact) / norm(‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_exact)
            @assert err < 1e-6
            # Note: the highest value seen so far is ~3e-7 (only applies to œÅe)
        end

        ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_approx = matrix_column(‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ, axes(Y.c), i, j, h)
        ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_exact = exact_column_jacobian_block(args..., (:f, :w), (:c, :œÅ))
        if flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :exact
            @assert ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_approx ‚âà ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_exact
        else
            err = norm(‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_approx .- ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_exact) / norm(‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_exact)
            @assert err < 0.03
            # Note: the highest value seen so far for œÅe is ~0.01, and the
            # highest value seen so far for œÅŒ∏ is ~0.02
        end
    end
end
